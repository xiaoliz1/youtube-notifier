#!/usr/bin/env python3
import os
import json
import feedparser
import requests
from datetime import datetime
from telegram import Bot, InputMediaPhoto
from telegram.error import TelegramError
import sys
import re

# ========= 配置区 =========
STATE_FILE = "state.json"
CHANNELS_FILE = "channels.txt"
TG_TOKEN = os.getenv("TG_TOKEN")      # GitHub Secret
TG_CHAT_ID = os.getenv("TG_CHAT_ID")  # GitHub Secret
CHECK_INTERVAL_MIN = 30  # 最小间隔，防止重复通知
# =========================

if not TG_TOKEN or not TG_CHAT_ID:
    print("❌ TG_TOKEN 或 TG_CHAT_ID 未设置")
    sys.exit(1)

bot = Bot(token=TG_TOKEN)

def load_state():
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE, 'r') as f:
            return json.load(f)
    return {}

def save_state(state):
    with open(STATE_FILE, 'w') as f:
        json.dump(state, f, indent=2)

def is_valid_channel_id(cid):
    if cid.startswith("UC"):
        return bool(re.match(r'^UC[a-zA-Z0-9_-]{22}$', cid))
    return True  # 用户名也允许

def get_rss_url(channel):
    channel = channel.strip()
    if channel.startswith("@"):
        # 用户名转 ID（通过页面抓取）
        url = f"https://www.youtube.com/{channel}"
        try:
            resp = requests.get(url, timeout=10, headers={'User-Agent': 'Mozilla/5.0'})
            if resp.status_code != 200:
                return None
            # 查找 channel_id
            m = re.search(r'"channelId":"(UC[a-zA-Z0-9_-]{22})"', resp.text)
            if m:
                return f"https://www.youtube.com/feeds/videos.xml?channel_id={m.group(1)}"
        except:
            pass
        return None
    elif channel.startswith("UC"):
        return f"https://www.youtube.com/feeds/videos.xml?channel_id={channel}"
    else:
        return None

def check_channel(channel_id, last_video_id, last_check_time):
    rss_url = get_rss_url(channel_id)
    if not rss_url:
        return None, f"❌ 频道无效或无法解析: {channel_id}"

    feed = feedparser.parse(rss_url)
    if feed.bozo or not feed.entries:
        return None, f"❌ 频道 RSS 无效或无视频: {channel_id}"

    latest = feed.entries[0]
    video_id = latest.id.split(":")[-1]
    published = datetime(*latest.published_parsed[:6])

    # 跳过旧视频或频繁通知
    if video_id == last_video_id:
        return None, "无更新"
    if last_check_time:
        time_diff = datetime.now() - last_check_time
        if time_diff.total_seconds() < CHECK_INTERVAL_MIN * 60:
            return None, "时间太近，跳过"

    # 构建消息
    title = latest.title
    link = latest.link
    summary = latest.summary[:500] + "..." if len(latest.summary) > 500 else latest.summary
    thumb = latest.media_thumbnail[0]['url'] if 'media_thumbnail' in latest else None

    message = f"""
*新视频更新！*

*频道*: `{channel_id}`
*标题*: [{title}]({link})
*发布时间*: {published.strftime('%Y-%m-%d %H:%M')} (UTC)

{summary}
""".strip()

    return {
        "video_id": video_id,
        "title": title,
        "link": link,
        "thumb": thumb,
        "message": message,
        "published": published.isoformat()
    }, "更新成功"

def send_telegram(update):
    try:
        if update['thumb']:
            bot.send_photo(
                chat_id=TG_CHAT_ID,
                photo=update['thumb'],
                caption=update['message'],
                parse_mode='Markdown',
                disable_web_page_preview=False
            )
        else:
            bot.send_message(
                chat_id=TG_CHAT_ID,
                text=update['message'],
                parse_mode='Markdown',
                disable_web_page_preview=True
            )
        print(f"✅ 已通知: {update['title']}")
    except TelegramError as e:
        print(f"❌ TG 发送失败: {e}")

def main():
    state = load_state()
    channels = [line.strip() for line in open(CHANNELS_FILE) if line.strip() and not line.startswith("#")]
    new_state = {}
    now = datetime.now()

    for ch in channels:
        last_id = state.get(ch, {}).get("last_video_id")
        last_time = state.get(ch, {}).get("last_check_time")
        if last_time:
            last_time = datetime.fromisoformat(last_time)

        update, status = check_channel(ch, last_id, last_time)
        print(f"[{ch}] {status}")

        if update:
            send_telegram(update)
            new_state[ch] = {
                "last_video_id": update['video_id'],
                "last_check_time": now.isoformat()
            }
        else:
            # 保留旧状态（用于频率控制）
            new_state[ch] = state.get(ch, {
                "last_video_id": last_id,
                "last_check_time": now.isoformat()
            })

    save_state(new_state)

if __name__ == "__main__":
    main()